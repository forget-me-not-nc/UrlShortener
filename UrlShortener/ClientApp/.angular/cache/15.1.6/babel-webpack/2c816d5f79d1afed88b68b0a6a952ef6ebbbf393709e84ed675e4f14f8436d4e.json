{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, Inject, EventEmitter, Directive, Input, Output, NgModule } from '@angular/core';\nimport { BehaviorSubject, of, from, merge, forkJoin } from 'rxjs';\nimport { map, switchMap, catchError, mergeAll, first, mergeMap, every, skip, take, tap } from 'rxjs/operators';\nimport * as i3 from '@angular/router';\nconst NgxPermissionsPredefinedStrategies = {\n  REMOVE: 'remove',\n  SHOW: 'show'\n};\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\nfunction isPlainObject(value) {\n  if (Object.prototype.toString.call(value) !== '[object Object]') {\n    return false;\n  } else {\n    const prototype = Object.getPrototypeOf(value);\n    return prototype === null || prototype === Object.prototype;\n  }\n}\nfunction isString(value) {\n  return !!value && typeof value === 'string';\n}\nfunction isBoolean(value) {\n  return typeof value === 'boolean';\n}\nfunction isPromise(promise) {\n  return Object.prototype.toString.call(promise) === '[object Promise]';\n}\nfunction notEmptyValue(value) {\n  if (Array.isArray(value)) {\n    return value.length > 0;\n  }\n  return !!value;\n}\nfunction transformStringToArray(value) {\n  if (isString(value)) {\n    return [value];\n  }\n  return value;\n}\nclass NgxPermissionsStore {\n  constructor() {\n    this.permissionsSource = new BehaviorSubject({});\n    this.permissions$ = this.permissionsSource.asObservable();\n  }\n}\nNgxPermissionsStore.ɵfac = function NgxPermissionsStore_Factory(t) {\n  return new (t || NgxPermissionsStore)();\n};\nNgxPermissionsStore.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxPermissionsStore,\n  factory: NgxPermissionsStore.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsStore, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\nconst USE_PERMISSIONS_STORE = new InjectionToken('USE_PERMISSIONS_STORE');\nclass NgxPermissionsService {\n  constructor(isolate = false, permissionsStore) {\n    this.isolate = isolate;\n    this.permissionsStore = permissionsStore;\n    this.permissionsSource = isolate ? new BehaviorSubject({}) : permissionsStore.permissionsSource;\n    this.permissions$ = this.permissionsSource.asObservable();\n  }\n  /**\n   * Remove all permissions from permissions source\n   */\n  flushPermissions() {\n    this.permissionsSource.next({});\n  }\n  hasPermission(permission) {\n    if (!permission || Array.isArray(permission) && permission.length === 0) {\n      return Promise.resolve(true);\n    }\n    permission = transformStringToArray(permission);\n    return this.hasArrayPermission(permission);\n  }\n  loadPermissions(permissions, validationFunction) {\n    const newPermissions = permissions.reduce((source, name) => this.reducePermission(source, name, validationFunction), {});\n    this.permissionsSource.next(newPermissions);\n  }\n  addPermission(permission, validationFunction) {\n    if (Array.isArray(permission)) {\n      const permissions = permission.reduce((source, name) => this.reducePermission(source, name, validationFunction), this.permissionsSource.value);\n      this.permissionsSource.next(permissions);\n    } else {\n      const permissions = this.reducePermission(this.permissionsSource.value, permission, validationFunction);\n      this.permissionsSource.next(permissions);\n    }\n  }\n  removePermission(permissionName) {\n    const permissions = {\n      ...this.permissionsSource.value\n    };\n    delete permissions[permissionName];\n    this.permissionsSource.next(permissions);\n  }\n  getPermission(name) {\n    return this.permissionsSource.value[name];\n  }\n  getPermissions() {\n    return this.permissionsSource.value;\n  }\n  reducePermission(source, name, validationFunction) {\n    if (!!validationFunction && isFunction(validationFunction)) {\n      return {\n        ...source,\n        [name]: {\n          name,\n          validationFunction\n        }\n      };\n    }\n    return {\n      ...source,\n      [name]: {\n        name\n      }\n    };\n  }\n  hasArrayPermission(permissions) {\n    const promises = permissions.map(key => {\n      if (this.hasPermissionValidationFunction(key)) {\n        const validationFunction = this.permissionsSource.value[key].validationFunction;\n        const immutableValue = {\n          ...this.permissionsSource.value\n        };\n        return of(null).pipe(map(() => validationFunction(key, immutableValue)), switchMap(promise => isBoolean(promise) ? of(promise) : promise), catchError(() => of(false)));\n      }\n      // check for name of the permission if there is no validation function\n      return of(!!this.permissionsSource.value[key]);\n    });\n    return from(promises).pipe(mergeAll(), first(data => data !== false, false), map(data => data !== false)).toPromise().then(data => data);\n  }\n  hasPermissionValidationFunction(key) {\n    return !!this.permissionsSource.value[key] && !!this.permissionsSource.value[key].validationFunction && isFunction(this.permissionsSource.value[key].validationFunction);\n  }\n}\nNgxPermissionsService.ɵfac = function NgxPermissionsService_Factory(t) {\n  return new (t || NgxPermissionsService)(i0.ɵɵinject(USE_PERMISSIONS_STORE), i0.ɵɵinject(NgxPermissionsStore));\n};\nNgxPermissionsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxPermissionsService,\n  factory: NgxPermissionsService.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [USE_PERMISSIONS_STORE]\n      }]\n    }, {\n      type: NgxPermissionsStore\n    }];\n  }, null);\n})();\nclass NgxPermissionsConfigurationStore {\n  constructor() {\n    this.strategiesSource = new BehaviorSubject({});\n    this.strategies$ = this.strategiesSource.asObservable();\n  }\n}\nNgxPermissionsConfigurationStore.ɵfac = function NgxPermissionsConfigurationStore_Factory(t) {\n  return new (t || NgxPermissionsConfigurationStore)();\n};\nNgxPermissionsConfigurationStore.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxPermissionsConfigurationStore,\n  factory: NgxPermissionsConfigurationStore.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsConfigurationStore, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\nconst USE_CONFIGURATION_STORE = new InjectionToken('USE_CONFIGURATION_STORE');\nclass NgxPermissionsConfigurationService {\n  constructor(isolate = false, configurationStore) {\n    this.isolate = isolate;\n    this.configurationStore = configurationStore;\n    this.strategiesSource = this.isolate ? new BehaviorSubject({}) : this.configurationStore.strategiesSource;\n    this.strategies$ = this.strategiesSource.asObservable();\n    this.onAuthorisedDefaultStrategy = this.isolate ? undefined : this.configurationStore.onAuthorisedDefaultStrategy;\n    this.onUnAuthorisedDefaultStrategy = this.isolate ? undefined : this.configurationStore.onUnAuthorisedDefaultStrategy;\n  }\n  setDefaultOnAuthorizedStrategy(name) {\n    if (this.isolate) {\n      this.onAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n    } else {\n      this.configurationStore.onAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n      this.onAuthorisedDefaultStrategy = this.configurationStore.onAuthorisedDefaultStrategy;\n    }\n  }\n  setDefaultOnUnauthorizedStrategy(name) {\n    if (this.isolate) {\n      this.onUnAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n    } else {\n      this.configurationStore.onUnAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n      this.onUnAuthorisedDefaultStrategy = this.configurationStore.onUnAuthorisedDefaultStrategy;\n    }\n  }\n  addPermissionStrategy(key, func) {\n    this.strategiesSource.value[key] = func;\n  }\n  getStrategy(key) {\n    return this.strategiesSource.value[key];\n  }\n  getAllStrategies() {\n    return this.strategiesSource.value;\n  }\n  getDefinedStrategy(name) {\n    if (this.strategiesSource.value[name] || this.isPredefinedStrategy(name)) {\n      return name;\n    } else {\n      throw new Error(`No ' ${name} ' strategy is found please define one`);\n    }\n  }\n  isPredefinedStrategy(strategy) {\n    return strategy === NgxPermissionsPredefinedStrategies.SHOW || strategy === NgxPermissionsPredefinedStrategies.REMOVE;\n  }\n}\nNgxPermissionsConfigurationService.ɵfac = function NgxPermissionsConfigurationService_Factory(t) {\n  return new (t || NgxPermissionsConfigurationService)(i0.ɵɵinject(USE_CONFIGURATION_STORE), i0.ɵɵinject(NgxPermissionsConfigurationStore));\n};\nNgxPermissionsConfigurationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxPermissionsConfigurationService,\n  factory: NgxPermissionsConfigurationService.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsConfigurationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [USE_CONFIGURATION_STORE]\n      }]\n    }, {\n      type: NgxPermissionsConfigurationStore\n    }];\n  }, null);\n})();\nclass NgxRolesStore {\n  constructor() {\n    this.rolesSource = new BehaviorSubject({});\n    this.roles$ = this.rolesSource.asObservable();\n  }\n}\nconst USE_ROLES_STORE = new InjectionToken('USE_ROLES_STORE');\nclass NgxRolesService {\n  constructor(isolate = false, rolesStore, permissionsService) {\n    this.isolate = isolate;\n    this.rolesStore = rolesStore;\n    this.permissionsService = permissionsService;\n    this.rolesSource = this.isolate ? new BehaviorSubject({}) : this.rolesStore.rolesSource;\n    this.roles$ = this.rolesSource.asObservable();\n  }\n  addRole(name, validationFunction) {\n    const roles = {\n      ...this.rolesSource.value,\n      [name]: {\n        name,\n        validationFunction\n      }\n    };\n    this.rolesSource.next(roles);\n  }\n  addRoleWithPermissions(name, permissions) {\n    this.permissionsService.addPermission(permissions);\n    this.addRole(name, permissions);\n  }\n  addRoles(rolesObj) {\n    Object.keys(rolesObj).forEach((key, index) => {\n      this.addRole(key, rolesObj[key]);\n    });\n  }\n  addRolesWithPermissions(rolesObj) {\n    Object.keys(rolesObj).forEach((key, index) => {\n      this.addRoleWithPermissions(key, rolesObj[key]);\n    });\n  }\n  flushRoles() {\n    this.rolesSource.next({});\n  }\n  flushRolesAndPermissions() {\n    this.flushRoles();\n    this.permissionsService.flushPermissions();\n  }\n  removeRole(roleName) {\n    const roles = {\n      ...this.rolesSource.value\n    };\n    delete roles[roleName];\n    this.rolesSource.next(roles);\n  }\n  getRoles() {\n    return this.rolesSource.value;\n  }\n  getRole(name) {\n    return this.rolesSource.value[name];\n  }\n  hasOnlyRoles(names) {\n    const isNamesEmpty = !names || Array.isArray(names) && names.length === 0;\n    if (isNamesEmpty) {\n      return Promise.resolve(true);\n    }\n    names = transformStringToArray(names);\n    return Promise.all([this.hasRoleKey(names), this.hasRolePermission(this.rolesSource.value, names)]).then(([hasRoles, hasPermissions]) => {\n      return hasRoles || hasPermissions;\n    });\n  }\n  hasRoleKey(roleName) {\n    const promises = roleName.map(key => {\n      const hasValidationFunction = !!this.rolesSource.value[key] && !!this.rolesSource.value[key].validationFunction && isFunction(this.rolesSource.value[key].validationFunction);\n      if (hasValidationFunction && !isPromise(this.rolesSource.value[key].validationFunction)) {\n        const validationFunction = this.rolesSource.value[key].validationFunction;\n        const immutableValue = {\n          ...this.rolesSource.value\n        };\n        return of(null).pipe(map(() => validationFunction(key, immutableValue)), switchMap(promise => isBoolean(promise) ? of(promise) : promise), catchError(() => of(false)));\n      }\n      return of(false);\n    });\n    return from(promises).pipe(mergeAll(), first(data => data !== false, false), map(data => data !== false)).toPromise().then(data => data);\n  }\n  hasRolePermission(roles, roleNames) {\n    return from(roleNames).pipe(mergeMap(key => {\n      if (roles[key] && Array.isArray(roles[key].validationFunction)) {\n        return from(roles[key].validationFunction).pipe(mergeMap(permission => this.permissionsService.hasPermission(permission)), every(hasPermission => hasPermission === true));\n      }\n      return of(false);\n    }), first(hasPermission => hasPermission === true, false)).toPromise();\n  }\n}\nNgxRolesService.ɵfac = function NgxRolesService_Factory(t) {\n  return new (t || NgxRolesService)(i0.ɵɵinject(USE_ROLES_STORE), i0.ɵɵinject(NgxRolesStore), i0.ɵɵinject(NgxPermissionsService));\n};\nNgxRolesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxRolesService,\n  factory: NgxRolesService.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxRolesService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [USE_ROLES_STORE]\n      }]\n    }, {\n      type: NgxRolesStore\n    }, {\n      type: NgxPermissionsService\n    }];\n  }, null);\n})();\nclass NgxPermissionsDirective {\n  constructor(permissionsService, configurationService, rolesService, viewContainer, changeDetector, templateRef) {\n    this.permissionsService = permissionsService;\n    this.configurationService = configurationService;\n    this.rolesService = rolesService;\n    this.viewContainer = viewContainer;\n    this.changeDetector = changeDetector;\n    this.templateRef = templateRef;\n    this.permissionsAuthorized = new EventEmitter();\n    this.permissionsUnauthorized = new EventEmitter();\n    // skip first run cause merge will fire twice\n    this.firstMergeUnusedRun = 1;\n  }\n  ngOnInit() {\n    this.viewContainer.clear();\n    this.initPermissionSubscription = this.validateExceptOnlyPermissions();\n  }\n  ngOnChanges(changes) {\n    const onlyChanges = changes['ngxPermissionsOnly'];\n    const exceptChanges = changes['ngxPermissionsExcept'];\n    if (onlyChanges || exceptChanges) {\n      // Due to bug when you pass empty array\n      if (onlyChanges && onlyChanges.firstChange) {\n        return;\n      }\n      if (exceptChanges && exceptChanges.firstChange) {\n        return;\n      }\n      merge(this.permissionsService.permissions$, this.rolesService.roles$).pipe(skip(this.firstMergeUnusedRun), take(1)).subscribe(() => {\n        if (notEmptyValue(this.ngxPermissionsExcept)) {\n          this.validateExceptAndOnlyPermissions();\n          return;\n        }\n        if (notEmptyValue(this.ngxPermissionsOnly)) {\n          this.validateOnlyPermissions();\n          return;\n        }\n        this.handleAuthorisedPermission(this.getAuthorisedTemplates());\n      });\n    }\n  }\n  ngOnDestroy() {\n    if (this.initPermissionSubscription) {\n      this.initPermissionSubscription.unsubscribe();\n    }\n  }\n  validateExceptOnlyPermissions() {\n    return merge(this.permissionsService.permissions$, this.rolesService.roles$).pipe(skip(this.firstMergeUnusedRun)).subscribe(() => {\n      if (notEmptyValue(this.ngxPermissionsExcept)) {\n        this.validateExceptAndOnlyPermissions();\n        return;\n      }\n      if (notEmptyValue(this.ngxPermissionsOnly)) {\n        this.validateOnlyPermissions();\n        return;\n      }\n      this.handleAuthorisedPermission(this.getAuthorisedTemplates());\n    });\n  }\n  validateExceptAndOnlyPermissions() {\n    Promise.all([this.permissionsService.hasPermission(this.ngxPermissionsExcept), this.rolesService.hasOnlyRoles(this.ngxPermissionsExcept)]).then(([hasPermission, hasRole]) => {\n      if (hasPermission || hasRole) {\n        this.handleUnauthorisedPermission(this.ngxPermissionsExceptElse || this.ngxPermissionsElse);\n        return;\n      }\n      if (!!this.ngxPermissionsOnly) {\n        throw false;\n      }\n      this.handleAuthorisedPermission(this.ngxPermissionsExceptThen || this.ngxPermissionsThen || this.templateRef);\n    }).catch(() => {\n      if (!!this.ngxPermissionsOnly) {\n        this.validateOnlyPermissions();\n      } else {\n        this.handleAuthorisedPermission(this.ngxPermissionsExceptThen || this.ngxPermissionsThen || this.templateRef);\n      }\n    });\n  }\n  validateOnlyPermissions() {\n    Promise.all([this.permissionsService.hasPermission(this.ngxPermissionsOnly), this.rolesService.hasOnlyRoles(this.ngxPermissionsOnly)]).then(([hasPermissions, hasRoles]) => {\n      if (hasPermissions || hasRoles) {\n        this.handleAuthorisedPermission(this.ngxPermissionsOnlyThen || this.ngxPermissionsThen || this.templateRef);\n      } else {\n        this.handleUnauthorisedPermission(this.ngxPermissionsOnlyElse || this.ngxPermissionsElse);\n      }\n    }).catch(() => {\n      this.handleUnauthorisedPermission(this.ngxPermissionsOnlyElse || this.ngxPermissionsElse);\n    });\n  }\n  handleUnauthorisedPermission(template) {\n    if (isBoolean(this.currentAuthorizedState) && !this.currentAuthorizedState) {\n      return;\n    }\n    this.currentAuthorizedState = false;\n    this.permissionsUnauthorized.emit();\n    if (this.getUnAuthorizedStrategyInput()) {\n      this.applyStrategyAccordingToStrategyType(this.getUnAuthorizedStrategyInput());\n      return;\n    }\n    if (this.configurationService.onUnAuthorisedDefaultStrategy && !this.elseBlockDefined()) {\n      this.applyStrategy(this.configurationService.onUnAuthorisedDefaultStrategy);\n    } else {\n      this.showTemplateBlockInView(template);\n    }\n  }\n  handleAuthorisedPermission(template) {\n    if (isBoolean(this.currentAuthorizedState) && this.currentAuthorizedState) {\n      return;\n    }\n    this.currentAuthorizedState = true;\n    this.permissionsAuthorized.emit();\n    if (this.getAuthorizedStrategyInput()) {\n      this.applyStrategyAccordingToStrategyType(this.getAuthorizedStrategyInput());\n      return;\n    }\n    if (this.configurationService.onAuthorisedDefaultStrategy && !this.thenBlockDefined()) {\n      this.applyStrategy(this.configurationService.onAuthorisedDefaultStrategy);\n    } else {\n      this.showTemplateBlockInView(template);\n    }\n  }\n  applyStrategyAccordingToStrategyType(strategy) {\n    if (isString(strategy)) {\n      this.applyStrategy(strategy);\n      return;\n    }\n    if (isFunction(strategy)) {\n      this.showTemplateBlockInView(this.templateRef);\n      strategy(this.templateRef);\n      return;\n    }\n  }\n  showTemplateBlockInView(template) {\n    this.viewContainer.clear();\n    if (!template) {\n      return;\n    }\n    this.viewContainer.createEmbeddedView(template);\n    this.changeDetector.markForCheck();\n  }\n  getAuthorisedTemplates() {\n    return this.ngxPermissionsOnlyThen || this.ngxPermissionsExceptThen || this.ngxPermissionsThen || this.templateRef;\n  }\n  elseBlockDefined() {\n    return !!this.ngxPermissionsExceptElse || !!this.ngxPermissionsElse;\n  }\n  thenBlockDefined() {\n    return !!this.ngxPermissionsExceptThen || !!this.ngxPermissionsThen;\n  }\n  getAuthorizedStrategyInput() {\n    return this.ngxPermissionsOnlyAuthorisedStrategy || this.ngxPermissionsExceptAuthorisedStrategy || this.ngxPermissionsAuthorisedStrategy;\n  }\n  getUnAuthorizedStrategyInput() {\n    return this.ngxPermissionsOnlyUnauthorisedStrategy || this.ngxPermissionsExceptUnauthorisedStrategy || this.ngxPermissionsUnauthorisedStrategy;\n  }\n  applyStrategy(name) {\n    if (name === NgxPermissionsPredefinedStrategies.SHOW) {\n      this.showTemplateBlockInView(this.templateRef);\n      return;\n    }\n    if (name === NgxPermissionsPredefinedStrategies.REMOVE) {\n      this.viewContainer.clear();\n      return;\n    }\n    const strategy = this.configurationService.getStrategy(name);\n    this.showTemplateBlockInView(this.templateRef);\n    strategy(this.templateRef);\n  }\n}\nNgxPermissionsDirective.ɵfac = function NgxPermissionsDirective_Factory(t) {\n  return new (t || NgxPermissionsDirective)(i0.ɵɵdirectiveInject(NgxPermissionsService), i0.ɵɵdirectiveInject(NgxPermissionsConfigurationService), i0.ɵɵdirectiveInject(NgxRolesService), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.TemplateRef));\n};\nNgxPermissionsDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: NgxPermissionsDirective,\n  selectors: [[\"\", \"ngxPermissionsOnly\", \"\"], [\"\", \"ngxPermissionsExcept\", \"\"]],\n  inputs: {\n    ngxPermissionsOnly: \"ngxPermissionsOnly\",\n    ngxPermissionsOnlyThen: \"ngxPermissionsOnlyThen\",\n    ngxPermissionsOnlyElse: \"ngxPermissionsOnlyElse\",\n    ngxPermissionsExcept: \"ngxPermissionsExcept\",\n    ngxPermissionsExceptElse: \"ngxPermissionsExceptElse\",\n    ngxPermissionsExceptThen: \"ngxPermissionsExceptThen\",\n    ngxPermissionsThen: \"ngxPermissionsThen\",\n    ngxPermissionsElse: \"ngxPermissionsElse\",\n    ngxPermissionsOnlyAuthorisedStrategy: \"ngxPermissionsOnlyAuthorisedStrategy\",\n    ngxPermissionsOnlyUnauthorisedStrategy: \"ngxPermissionsOnlyUnauthorisedStrategy\",\n    ngxPermissionsExceptUnauthorisedStrategy: \"ngxPermissionsExceptUnauthorisedStrategy\",\n    ngxPermissionsExceptAuthorisedStrategy: \"ngxPermissionsExceptAuthorisedStrategy\",\n    ngxPermissionsUnauthorisedStrategy: \"ngxPermissionsUnauthorisedStrategy\",\n    ngxPermissionsAuthorisedStrategy: \"ngxPermissionsAuthorisedStrategy\"\n  },\n  outputs: {\n    permissionsAuthorized: \"permissionsAuthorized\",\n    permissionsUnauthorized: \"permissionsUnauthorized\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxPermissionsOnly],[ngxPermissionsExcept]'\n    }]\n  }], function () {\n    return [{\n      type: NgxPermissionsService\n    }, {\n      type: NgxPermissionsConfigurationService\n    }, {\n      type: NgxRolesService\n    }, {\n      type: i0.ViewContainerRef\n    }, {\n      type: i0.ChangeDetectorRef\n    }, {\n      type: i0.TemplateRef\n    }];\n  }, {\n    ngxPermissionsOnly: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyThen: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyElse: [{\n      type: Input\n    }],\n    ngxPermissionsExcept: [{\n      type: Input\n    }],\n    ngxPermissionsExceptElse: [{\n      type: Input\n    }],\n    ngxPermissionsExceptThen: [{\n      type: Input\n    }],\n    ngxPermissionsThen: [{\n      type: Input\n    }],\n    ngxPermissionsElse: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyAuthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsExceptUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsExceptAuthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsAuthorisedStrategy: [{\n      type: Input\n    }],\n    permissionsAuthorized: [{\n      type: Output\n    }],\n    permissionsUnauthorized: [{\n      type: Output\n    }]\n  });\n})();\nconst DEFAULT_REDIRECT_KEY = 'default';\nclass NgxPermissionsGuard {\n  constructor(permissionsService, rolesService, router) {\n    this.permissionsService = permissionsService;\n    this.rolesService = rolesService;\n    this.router = router;\n  }\n  canActivate(route, state) {\n    return this.hasPermissions(route, state);\n  }\n  canActivateChild(childRoute, state) {\n    return this.hasPermissions(childRoute, state);\n  }\n  canLoad(route) {\n    return this.hasPermissions(route);\n  }\n  canMatch(route) {\n    return this.hasPermissions(route);\n  }\n  hasPermissions(route, state) {\n    const routeDataPermissions = !!route && route.data ? route.data['permissions'] : {};\n    const permissions = this.transformPermission(routeDataPermissions, route, state);\n    if (this.isParameterAvailable(permissions.except)) {\n      return this.passingExceptPermissionsValidation(permissions, route, state);\n    }\n    if (this.isParameterAvailable(permissions.only)) {\n      return this.passingOnlyPermissionsValidation(permissions, route, state);\n    }\n    return true;\n  }\n  transformPermission(permissions, route, state) {\n    const only = isFunction(permissions.only) ? permissions.only(route, state) : transformStringToArray(permissions.only);\n    const except = isFunction(permissions.except) ? permissions.except(route, state) : transformStringToArray(permissions.except);\n    const redirectTo = permissions.redirectTo;\n    return {\n      only,\n      except,\n      redirectTo\n    };\n  }\n  isParameterAvailable(permission) {\n    return !!permission && permission.length > 0;\n  }\n  passingExceptPermissionsValidation(permissions, route, state) {\n    if (!!permissions.redirectTo && (isFunction(permissions.redirectTo) || isPlainObject(permissions.redirectTo) && !this.isRedirectionWithParameters(permissions.redirectTo))) {\n      let failedPermission = '';\n      return from(permissions.except).pipe(mergeMap(permissionsExcept => {\n        return forkJoin([this.permissionsService.hasPermission(permissionsExcept), this.rolesService.hasOnlyRoles(permissionsExcept)]).pipe(tap(hasPermissions => {\n          const dontHavePermissions = hasPermissions.every(hasPermission => hasPermission === false);\n          if (!dontHavePermissions) {\n            failedPermission = permissionsExcept;\n          }\n        }));\n      }), first(hasPermissions => hasPermissions.some(hasPermission => hasPermission === true), false), mergeMap(isAllFalse => {\n        if (!!failedPermission) {\n          this.handleRedirectOfFailedPermission(permissions, failedPermission, route, state);\n          return of(false);\n        }\n        if (!isAllFalse && permissions.only) {\n          return this.onlyRedirectCheck(permissions, route, state);\n        }\n        return of(!isAllFalse);\n      })).toPromise();\n    }\n    return Promise.all([this.permissionsService.hasPermission(permissions.except), this.rolesService.hasOnlyRoles(permissions.except)]).then(([hasPermission, hasRoles]) => {\n      if (hasPermission || hasRoles) {\n        if (permissions.redirectTo) {\n          this.redirectToAnotherRoute(permissions.redirectTo, route, state);\n        }\n        return false;\n      }\n      if (permissions.only) {\n        return this.checkOnlyPermissions(permissions, route, state);\n      }\n      return true;\n    });\n  }\n  redirectToAnotherRoute(permissionRedirectTo, route, state, failedPermissionName) {\n    const redirectTo = isFunction(permissionRedirectTo) ? permissionRedirectTo(failedPermissionName, route, state) : permissionRedirectTo;\n    if (this.isRedirectionWithParameters(redirectTo)) {\n      redirectTo.navigationCommands = this.transformNavigationCommands(redirectTo.navigationCommands, route, state);\n      redirectTo.navigationExtras = this.transformNavigationExtras(redirectTo.navigationExtras, route, state);\n      this.router.navigate(redirectTo.navigationCommands, redirectTo.navigationExtras);\n      return;\n    }\n    if (Array.isArray(redirectTo)) {\n      this.router.navigate(redirectTo);\n    } else {\n      this.router.navigate([redirectTo]);\n    }\n  }\n  isRedirectionWithParameters(object) {\n    return isPlainObject(object) && (!!object.navigationCommands || !!object.navigationExtras);\n  }\n  transformNavigationCommands(navigationCommands, route, state) {\n    return isFunction(navigationCommands) ? navigationCommands(route, state) : navigationCommands;\n  }\n  transformNavigationExtras(navigationExtras, route, state) {\n    return isFunction(navigationExtras) ? navigationExtras(route, state) : navigationExtras;\n  }\n  onlyRedirectCheck(permissions, route, state) {\n    let failedPermission = '';\n    return from(permissions.only).pipe(mergeMap(permissionsOnly => {\n      return forkJoin([this.permissionsService.hasPermission(permissionsOnly), this.rolesService.hasOnlyRoles(permissionsOnly)]).pipe(tap(hasPermissions => {\n        const failed = hasPermissions.every(hasPermission => hasPermission === false);\n        if (failed) {\n          failedPermission = permissionsOnly;\n        }\n      }));\n    }), first(hasPermissions => {\n      if (isFunction(permissions.redirectTo)) {\n        return hasPermissions.some(hasPermission => hasPermission === true);\n      }\n      return hasPermissions.every(hasPermission => hasPermission === false);\n    }, false), mergeMap(pass => {\n      if (isFunction(permissions.redirectTo)) {\n        if (pass) {\n          return of(true);\n        } else {\n          this.handleRedirectOfFailedPermission(permissions, failedPermission, route, state);\n          return of(false);\n        }\n      } else {\n        if (!!failedPermission) {\n          this.handleRedirectOfFailedPermission(permissions, failedPermission, route, state);\n        }\n        return of(!pass);\n      }\n    })).toPromise();\n  }\n  handleRedirectOfFailedPermission(permissions, failedPermission, route, state) {\n    if (this.isFailedPermissionPropertyOfRedirectTo(permissions, failedPermission)) {\n      this.redirectToAnotherRoute(permissions.redirectTo[failedPermission], route, state, failedPermission);\n    } else {\n      if (isFunction(permissions.redirectTo)) {\n        this.redirectToAnotherRoute(permissions.redirectTo, route, state, failedPermission);\n      } else {\n        this.redirectToAnotherRoute(permissions.redirectTo[DEFAULT_REDIRECT_KEY], route, state, failedPermission);\n      }\n    }\n  }\n  isFailedPermissionPropertyOfRedirectTo(permissions, failedPermission) {\n    return !!permissions.redirectTo && permissions.redirectTo[failedPermission];\n  }\n  checkOnlyPermissions(purePermissions, route, state) {\n    const permissions = {\n      ...purePermissions\n    };\n    return Promise.all([this.permissionsService.hasPermission(permissions.only), this.rolesService.hasOnlyRoles(permissions.only)]).then(([hasPermission, hasRole]) => {\n      if (hasPermission || hasRole) {\n        return true;\n      }\n      if (permissions.redirectTo) {\n        this.redirectToAnotherRoute(permissions.redirectTo, route, state);\n      }\n      return false;\n    });\n  }\n  passingOnlyPermissionsValidation(permissions, route, state) {\n    if (isFunction(permissions.redirectTo) || isPlainObject(permissions.redirectTo) && !this.isRedirectionWithParameters(permissions.redirectTo)) {\n      return this.onlyRedirectCheck(permissions, route, state);\n    }\n    return this.checkOnlyPermissions(permissions, route, state);\n  }\n}\nNgxPermissionsGuard.ɵfac = function NgxPermissionsGuard_Factory(t) {\n  return new (t || NgxPermissionsGuard)(i0.ɵɵinject(NgxPermissionsService), i0.ɵɵinject(NgxRolesService), i0.ɵɵinject(i3.Router));\n};\nNgxPermissionsGuard.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxPermissionsGuard,\n  factory: NgxPermissionsGuard.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsGuard, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: NgxPermissionsService\n    }, {\n      type: NgxRolesService\n    }, {\n      type: i3.Router\n    }];\n  }, null);\n})();\nclass NgxPermissionsAllowStubDirective {\n  constructor(viewContainer, templateRef) {\n    this.viewContainer = viewContainer;\n    this.templateRef = templateRef;\n    this.permissionsAuthorized = new EventEmitter();\n    this.permissionsUnauthorized = new EventEmitter();\n  }\n  ngOnInit() {\n    this.viewContainer.clear();\n    this.viewContainer.createEmbeddedView(this.getAuthorizedTemplate());\n    this.permissionsUnauthorized.emit();\n  }\n  getAuthorizedTemplate() {\n    return this.ngxPermissionsOnlyThen || this.ngxPermissionsExceptThen || this.ngxPermissionsThen || this.templateRef;\n  }\n}\nNgxPermissionsAllowStubDirective.ɵfac = function NgxPermissionsAllowStubDirective_Factory(t) {\n  return new (t || NgxPermissionsAllowStubDirective)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.TemplateRef));\n};\nNgxPermissionsAllowStubDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: NgxPermissionsAllowStubDirective,\n  selectors: [[\"\", \"ngxPermissionsOnly\", \"\"], [\"\", \"ngxPermissionsExcept\", \"\"]],\n  inputs: {\n    ngxPermissionsOnly: \"ngxPermissionsOnly\",\n    ngxPermissionsOnlyThen: \"ngxPermissionsOnlyThen\",\n    ngxPermissionsOnlyElse: \"ngxPermissionsOnlyElse\",\n    ngxPermissionsExcept: \"ngxPermissionsExcept\",\n    ngxPermissionsExceptElse: \"ngxPermissionsExceptElse\",\n    ngxPermissionsExceptThen: \"ngxPermissionsExceptThen\",\n    ngxPermissionsThen: \"ngxPermissionsThen\",\n    ngxPermissionsElse: \"ngxPermissionsElse\",\n    ngxPermissionsOnlyAuthorisedStrategy: \"ngxPermissionsOnlyAuthorisedStrategy\",\n    ngxPermissionsOnlyUnauthorisedStrategy: \"ngxPermissionsOnlyUnauthorisedStrategy\",\n    ngxPermissionsExceptUnauthorisedStrategy: \"ngxPermissionsExceptUnauthorisedStrategy\",\n    ngxPermissionsExceptAuthorisedStrategy: \"ngxPermissionsExceptAuthorisedStrategy\",\n    ngxPermissionsUnauthorisedStrategy: \"ngxPermissionsUnauthorisedStrategy\",\n    ngxPermissionsAuthorisedStrategy: \"ngxPermissionsAuthorisedStrategy\"\n  },\n  outputs: {\n    permissionsAuthorized: \"permissionsAuthorized\",\n    permissionsUnauthorized: \"permissionsUnauthorized\"\n  },\n  standalone: true\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsAllowStubDirective, [{\n    type: Directive,\n    args: [{\n      standalone: true,\n      selector: '[ngxPermissionsOnly],[ngxPermissionsExcept]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ViewContainerRef\n    }, {\n      type: i0.TemplateRef\n    }];\n  }, {\n    ngxPermissionsOnly: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyThen: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyElse: [{\n      type: Input\n    }],\n    ngxPermissionsExcept: [{\n      type: Input\n    }],\n    ngxPermissionsExceptElse: [{\n      type: Input\n    }],\n    ngxPermissionsExceptThen: [{\n      type: Input\n    }],\n    ngxPermissionsThen: [{\n      type: Input\n    }],\n    ngxPermissionsElse: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyAuthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsExceptUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsExceptAuthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsAuthorisedStrategy: [{\n      type: Input\n    }],\n    permissionsAuthorized: [{\n      type: Output\n    }],\n    permissionsUnauthorized: [{\n      type: Output\n    }]\n  });\n})();\nclass NgxPermissionsRestrictStubDirective {\n  constructor(viewContainer) {\n    this.viewContainer = viewContainer;\n    this.permissionsAuthorized = new EventEmitter();\n    this.permissionsUnauthorized = new EventEmitter();\n  }\n  ngOnInit() {\n    this.viewContainer.clear();\n    if (this.getUnAuthorizedTemplate()) {\n      this.viewContainer.createEmbeddedView(this.getUnAuthorizedTemplate());\n    }\n    this.permissionsUnauthorized.emit();\n  }\n  getUnAuthorizedTemplate() {\n    return this.ngxPermissionsOnlyElse || this.ngxPermissionsExceptElse || this.ngxPermissionsElse;\n  }\n}\nNgxPermissionsRestrictStubDirective.ɵfac = function NgxPermissionsRestrictStubDirective_Factory(t) {\n  return new (t || NgxPermissionsRestrictStubDirective)(i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n};\nNgxPermissionsRestrictStubDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: NgxPermissionsRestrictStubDirective,\n  selectors: [[\"\", \"ngxPermissionsOnly\", \"\"], [\"\", \"ngxPermissionsExcept\", \"\"]],\n  inputs: {\n    ngxPermissionsOnly: \"ngxPermissionsOnly\",\n    ngxPermissionsOnlyThen: \"ngxPermissionsOnlyThen\",\n    ngxPermissionsOnlyElse: \"ngxPermissionsOnlyElse\",\n    ngxPermissionsExcept: \"ngxPermissionsExcept\",\n    ngxPermissionsExceptElse: \"ngxPermissionsExceptElse\",\n    ngxPermissionsExceptThen: \"ngxPermissionsExceptThen\",\n    ngxPermissionsThen: \"ngxPermissionsThen\",\n    ngxPermissionsElse: \"ngxPermissionsElse\",\n    ngxPermissionsOnlyAuthorisedStrategy: \"ngxPermissionsOnlyAuthorisedStrategy\",\n    ngxPermissionsOnlyUnauthorisedStrategy: \"ngxPermissionsOnlyUnauthorisedStrategy\",\n    ngxPermissionsExceptUnauthorisedStrategy: \"ngxPermissionsExceptUnauthorisedStrategy\",\n    ngxPermissionsExceptAuthorisedStrategy: \"ngxPermissionsExceptAuthorisedStrategy\",\n    ngxPermissionsUnauthorisedStrategy: \"ngxPermissionsUnauthorisedStrategy\",\n    ngxPermissionsAuthorisedStrategy: \"ngxPermissionsAuthorisedStrategy\"\n  },\n  outputs: {\n    permissionsAuthorized: \"permissionsAuthorized\",\n    permissionsUnauthorized: \"permissionsUnauthorized\"\n  },\n  standalone: true\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsRestrictStubDirective, [{\n    type: Directive,\n    args: [{\n      standalone: true,\n      selector: '[ngxPermissionsOnly],[ngxPermissionsExcept]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ViewContainerRef\n    }];\n  }, {\n    ngxPermissionsOnly: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyThen: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyElse: [{\n      type: Input\n    }],\n    ngxPermissionsExcept: [{\n      type: Input\n    }],\n    ngxPermissionsExceptElse: [{\n      type: Input\n    }],\n    ngxPermissionsExceptThen: [{\n      type: Input\n    }],\n    ngxPermissionsThen: [{\n      type: Input\n    }],\n    ngxPermissionsElse: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyAuthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsOnlyUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsExceptUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsExceptAuthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsUnauthorisedStrategy: [{\n      type: Input\n    }],\n    ngxPermissionsAuthorisedStrategy: [{\n      type: Input\n    }],\n    permissionsAuthorized: [{\n      type: Output\n    }],\n    permissionsUnauthorized: [{\n      type: Output\n    }]\n  });\n})();\nclass NgxPermissionsModule {\n  static forRoot(config = {}) {\n    return {\n      ngModule: NgxPermissionsModule,\n      providers: [NgxPermissionsStore, NgxRolesStore, NgxPermissionsConfigurationStore, NgxPermissionsService, NgxPermissionsGuard, NgxRolesService, NgxPermissionsConfigurationService, {\n        provide: USE_PERMISSIONS_STORE,\n        useValue: config.permissionsIsolate\n      }, {\n        provide: USE_ROLES_STORE,\n        useValue: config.rolesIsolate\n      }, {\n        provide: USE_CONFIGURATION_STORE,\n        useValue: config.configurationIsolate\n      }]\n    };\n  }\n  static forChild(config = {}) {\n    return {\n      ngModule: NgxPermissionsModule,\n      providers: [{\n        provide: USE_PERMISSIONS_STORE,\n        useValue: config.permissionsIsolate\n      }, {\n        provide: USE_ROLES_STORE,\n        useValue: config.rolesIsolate\n      }, {\n        provide: USE_CONFIGURATION_STORE,\n        useValue: config.configurationIsolate\n      }, NgxPermissionsConfigurationService, NgxPermissionsService, NgxRolesService, NgxPermissionsGuard]\n    };\n  }\n}\nNgxPermissionsModule.ɵfac = function NgxPermissionsModule_Factory(t) {\n  return new (t || NgxPermissionsModule)();\n};\nNgxPermissionsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxPermissionsModule\n});\nNgxPermissionsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsModule, [{\n    type: NgModule,\n    args: [{\n      imports: [],\n      declarations: [NgxPermissionsDirective],\n      exports: [NgxPermissionsDirective]\n    }]\n  }], null, null);\n})();\nclass NgxPermissionsAllowStubModule {}\nNgxPermissionsAllowStubModule.ɵfac = function NgxPermissionsAllowStubModule_Factory(t) {\n  return new (t || NgxPermissionsAllowStubModule)();\n};\nNgxPermissionsAllowStubModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxPermissionsAllowStubModule\n});\nNgxPermissionsAllowStubModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsAllowStubModule, [{\n    type: NgModule,\n    args: [{\n      imports: [NgxPermissionsAllowStubDirective],\n      declarations: [],\n      exports: [NgxPermissionsAllowStubDirective]\n    }]\n  }], null, null);\n})();\nclass NgxPermissionsRestrictStubModule {}\nNgxPermissionsRestrictStubModule.ɵfac = function NgxPermissionsRestrictStubModule_Factory(t) {\n  return new (t || NgxPermissionsRestrictStubModule)();\n};\nNgxPermissionsRestrictStubModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxPermissionsRestrictStubModule\n});\nNgxPermissionsRestrictStubModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxPermissionsRestrictStubModule, [{\n    type: NgModule,\n    args: [{\n      imports: [NgxPermissionsRestrictStubDirective],\n      declarations: [],\n      exports: [NgxPermissionsRestrictStubDirective]\n    }]\n  }], null, null);\n})();\n\n/*\n * Public API Surface of ngx-permissions\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DEFAULT_REDIRECT_KEY, NgxPermissionsAllowStubDirective, NgxPermissionsAllowStubModule, NgxPermissionsConfigurationService, NgxPermissionsConfigurationStore, NgxPermissionsDirective, NgxPermissionsGuard, NgxPermissionsModule, NgxPermissionsPredefinedStrategies, NgxPermissionsRestrictStubDirective, NgxPermissionsRestrictStubModule, NgxPermissionsService, NgxPermissionsStore, NgxRolesService, NgxRolesStore, USE_CONFIGURATION_STORE, USE_PERMISSIONS_STORE, USE_ROLES_STORE };","map":{"version":3,"names":["i0","Injectable","InjectionToken","Inject","EventEmitter","Directive","Input","Output","NgModule","BehaviorSubject","of","from","merge","forkJoin","map","switchMap","catchError","mergeAll","first","mergeMap","every","skip","take","tap","i3","NgxPermissionsPredefinedStrategies","REMOVE","SHOW","isFunction","value","isPlainObject","Object","prototype","toString","call","getPrototypeOf","isString","isBoolean","isPromise","promise","notEmptyValue","Array","isArray","length","transformStringToArray","NgxPermissionsStore","constructor","permissionsSource","permissions$","asObservable","ɵfac","ɵprov","type","USE_PERMISSIONS_STORE","NgxPermissionsService","isolate","permissionsStore","flushPermissions","next","hasPermission","permission","Promise","resolve","hasArrayPermission","loadPermissions","permissions","validationFunction","newPermissions","reduce","source","name","reducePermission","addPermission","removePermission","permissionName","getPermission","getPermissions","promises","key","hasPermissionValidationFunction","immutableValue","pipe","data","toPromise","then","undefined","decorators","args","NgxPermissionsConfigurationStore","strategiesSource","strategies$","USE_CONFIGURATION_STORE","NgxPermissionsConfigurationService","configurationStore","onAuthorisedDefaultStrategy","onUnAuthorisedDefaultStrategy","setDefaultOnAuthorizedStrategy","getDefinedStrategy","setDefaultOnUnauthorizedStrategy","addPermissionStrategy","func","getStrategy","getAllStrategies","isPredefinedStrategy","Error","strategy","NgxRolesStore","rolesSource","roles$","USE_ROLES_STORE","NgxRolesService","rolesStore","permissionsService","addRole","roles","addRoleWithPermissions","addRoles","rolesObj","keys","forEach","index","addRolesWithPermissions","flushRoles","flushRolesAndPermissions","removeRole","roleName","getRoles","getRole","hasOnlyRoles","names","isNamesEmpty","all","hasRoleKey","hasRolePermission","hasRoles","hasPermissions","hasValidationFunction","roleNames","NgxPermissionsDirective","configurationService","rolesService","viewContainer","changeDetector","templateRef","permissionsAuthorized","permissionsUnauthorized","firstMergeUnusedRun","ngOnInit","clear","initPermissionSubscription","validateExceptOnlyPermissions","ngOnChanges","changes","onlyChanges","exceptChanges","firstChange","subscribe","ngxPermissionsExcept","validateExceptAndOnlyPermissions","ngxPermissionsOnly","validateOnlyPermissions","handleAuthorisedPermission","getAuthorisedTemplates","ngOnDestroy","unsubscribe","hasRole","handleUnauthorisedPermission","ngxPermissionsExceptElse","ngxPermissionsElse","ngxPermissionsExceptThen","ngxPermissionsThen","catch","ngxPermissionsOnlyThen","ngxPermissionsOnlyElse","template","currentAuthorizedState","emit","getUnAuthorizedStrategyInput","applyStrategyAccordingToStrategyType","elseBlockDefined","applyStrategy","showTemplateBlockInView","getAuthorizedStrategyInput","thenBlockDefined","createEmbeddedView","markForCheck","ngxPermissionsOnlyAuthorisedStrategy","ngxPermissionsExceptAuthorisedStrategy","ngxPermissionsAuthorisedStrategy","ngxPermissionsOnlyUnauthorisedStrategy","ngxPermissionsExceptUnauthorisedStrategy","ngxPermissionsUnauthorisedStrategy","ViewContainerRef","ChangeDetectorRef","TemplateRef","ɵdir","selector","DEFAULT_REDIRECT_KEY","NgxPermissionsGuard","router","canActivate","route","state","canActivateChild","childRoute","canLoad","canMatch","routeDataPermissions","transformPermission","isParameterAvailable","except","passingExceptPermissionsValidation","only","passingOnlyPermissionsValidation","redirectTo","isRedirectionWithParameters","failedPermission","permissionsExcept","dontHavePermissions","some","isAllFalse","handleRedirectOfFailedPermission","onlyRedirectCheck","redirectToAnotherRoute","checkOnlyPermissions","permissionRedirectTo","failedPermissionName","navigationCommands","transformNavigationCommands","navigationExtras","transformNavigationExtras","navigate","object","permissionsOnly","failed","pass","isFailedPermissionPropertyOfRedirectTo","purePermissions","Router","NgxPermissionsAllowStubDirective","getAuthorizedTemplate","standalone","NgxPermissionsRestrictStubDirective","getUnAuthorizedTemplate","NgxPermissionsModule","forRoot","config","ngModule","providers","provide","useValue","permissionsIsolate","rolesIsolate","configurationIsolate","forChild","ɵmod","ɵinj","imports","declarations","exports","NgxPermissionsAllowStubModule","NgxPermissionsRestrictStubModule"],"sources":["D:/Inforce/UrlShortener/UrlShortener/ClientApp/node_modules/ngx-permissions/fesm2020/ngx-permissions.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, Inject, EventEmitter, Directive, Input, Output, NgModule } from '@angular/core';\nimport { BehaviorSubject, of, from, merge, forkJoin } from 'rxjs';\nimport { map, switchMap, catchError, mergeAll, first, mergeMap, every, skip, take, tap } from 'rxjs/operators';\nimport * as i3 from '@angular/router';\n\nconst NgxPermissionsPredefinedStrategies = {\n    REMOVE: 'remove',\n    SHOW: 'show'\n};\n\nfunction isFunction(value) {\n    return typeof value === 'function';\n}\nfunction isPlainObject(value) {\n    if (Object.prototype.toString.call(value) !== '[object Object]') {\n        return false;\n    }\n    else {\n        const prototype = Object.getPrototypeOf(value);\n        return prototype === null || prototype === Object.prototype;\n    }\n}\nfunction isString(value) {\n    return !!value && typeof value === 'string';\n}\nfunction isBoolean(value) {\n    return typeof value === 'boolean';\n}\nfunction isPromise(promise) {\n    return Object.prototype.toString.call(promise) === '[object Promise]';\n}\nfunction notEmptyValue(value) {\n    if (Array.isArray(value)) {\n        return value.length > 0;\n    }\n    return !!value;\n}\nfunction transformStringToArray(value) {\n    if (isString(value)) {\n        return [value];\n    }\n    return value;\n}\n\nclass NgxPermissionsStore {\n    constructor() {\n        this.permissionsSource = new BehaviorSubject({});\n        this.permissions$ = this.permissionsSource.asObservable();\n    }\n}\nNgxPermissionsStore.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsStore, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nNgxPermissionsStore.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsStore });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsStore, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return []; } });\n\nconst USE_PERMISSIONS_STORE = new InjectionToken('USE_PERMISSIONS_STORE');\nclass NgxPermissionsService {\n    constructor(isolate = false, permissionsStore) {\n        this.isolate = isolate;\n        this.permissionsStore = permissionsStore;\n        this.permissionsSource = isolate ? new BehaviorSubject({}) : permissionsStore.permissionsSource;\n        this.permissions$ = this.permissionsSource.asObservable();\n    }\n    /**\n     * Remove all permissions from permissions source\n     */\n    flushPermissions() {\n        this.permissionsSource.next({});\n    }\n    hasPermission(permission) {\n        if (!permission || (Array.isArray(permission) && permission.length === 0)) {\n            return Promise.resolve(true);\n        }\n        permission = transformStringToArray(permission);\n        return this.hasArrayPermission(permission);\n    }\n    loadPermissions(permissions, validationFunction) {\n        const newPermissions = permissions.reduce((source, name) => this.reducePermission(source, name, validationFunction), {});\n        this.permissionsSource.next(newPermissions);\n    }\n    addPermission(permission, validationFunction) {\n        if (Array.isArray(permission)) {\n            const permissions = permission.reduce((source, name) => this.reducePermission(source, name, validationFunction), this.permissionsSource.value);\n            this.permissionsSource.next(permissions);\n        }\n        else {\n            const permissions = this.reducePermission(this.permissionsSource.value, permission, validationFunction);\n            this.permissionsSource.next(permissions);\n        }\n    }\n    removePermission(permissionName) {\n        const permissions = {\n            ...this.permissionsSource.value\n        };\n        delete permissions[permissionName];\n        this.permissionsSource.next(permissions);\n    }\n    getPermission(name) {\n        return this.permissionsSource.value[name];\n    }\n    getPermissions() {\n        return this.permissionsSource.value;\n    }\n    reducePermission(source, name, validationFunction) {\n        if (!!validationFunction && isFunction(validationFunction)) {\n            return {\n                ...source,\n                [name]: { name, validationFunction }\n            };\n        }\n        return {\n            ...source,\n            [name]: { name }\n        };\n    }\n    hasArrayPermission(permissions) {\n        const promises = permissions.map(key => {\n            if (this.hasPermissionValidationFunction(key)) {\n                const validationFunction = this.permissionsSource.value[key].validationFunction;\n                const immutableValue = { ...this.permissionsSource.value };\n                return of(null).pipe(map(() => validationFunction(key, immutableValue)), switchMap((promise) => isBoolean(promise) ?\n                    of(promise) : promise), catchError(() => of(false)));\n            }\n            // check for name of the permission if there is no validation function\n            return of(!!this.permissionsSource.value[key]);\n        });\n        return from(promises).pipe(mergeAll(), first((data) => data !== false, false), map((data) => data !== false)).toPromise().then((data) => data);\n    }\n    hasPermissionValidationFunction(key) {\n        return !!this.permissionsSource.value[key] &&\n            !!this.permissionsSource.value[key].validationFunction &&\n            isFunction(this.permissionsSource.value[key].validationFunction);\n    }\n}\nNgxPermissionsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsService, deps: [{ token: USE_PERMISSIONS_STORE }, { token: NgxPermissionsStore }], target: i0.ɵɵFactoryTarget.Injectable });\nNgxPermissionsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [USE_PERMISSIONS_STORE]\n                }] }, { type: NgxPermissionsStore }]; } });\n\nclass NgxPermissionsConfigurationStore {\n    constructor() {\n        this.strategiesSource = new BehaviorSubject({});\n        this.strategies$ = this.strategiesSource.asObservable();\n    }\n}\nNgxPermissionsConfigurationStore.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsConfigurationStore, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nNgxPermissionsConfigurationStore.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsConfigurationStore });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsConfigurationStore, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return []; } });\n\nconst USE_CONFIGURATION_STORE = new InjectionToken('USE_CONFIGURATION_STORE');\nclass NgxPermissionsConfigurationService {\n    constructor(isolate = false, configurationStore) {\n        this.isolate = isolate;\n        this.configurationStore = configurationStore;\n        this.strategiesSource = this.isolate ? new BehaviorSubject({}) : this.configurationStore.strategiesSource;\n        this.strategies$ = this.strategiesSource.asObservable();\n        this.onAuthorisedDefaultStrategy = this.isolate ? undefined : this.configurationStore.onAuthorisedDefaultStrategy;\n        this.onUnAuthorisedDefaultStrategy = this.isolate ? undefined : this.configurationStore.onUnAuthorisedDefaultStrategy;\n    }\n    setDefaultOnAuthorizedStrategy(name) {\n        if (this.isolate) {\n            this.onAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n        }\n        else {\n            this.configurationStore.onAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n            this.onAuthorisedDefaultStrategy = this.configurationStore.onAuthorisedDefaultStrategy;\n        }\n    }\n    setDefaultOnUnauthorizedStrategy(name) {\n        if (this.isolate) {\n            this.onUnAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n        }\n        else {\n            this.configurationStore.onUnAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n            this.onUnAuthorisedDefaultStrategy = this.configurationStore.onUnAuthorisedDefaultStrategy;\n        }\n    }\n    addPermissionStrategy(key, func) {\n        this.strategiesSource.value[key] = func;\n    }\n    getStrategy(key) {\n        return this.strategiesSource.value[key];\n    }\n    getAllStrategies() {\n        return this.strategiesSource.value;\n    }\n    getDefinedStrategy(name) {\n        if (this.strategiesSource.value[name] || this.isPredefinedStrategy(name)) {\n            return name;\n        }\n        else {\n            throw new Error(`No ' ${name} ' strategy is found please define one`);\n        }\n    }\n    isPredefinedStrategy(strategy) {\n        return strategy === NgxPermissionsPredefinedStrategies.SHOW || strategy === NgxPermissionsPredefinedStrategies.REMOVE;\n    }\n}\nNgxPermissionsConfigurationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsConfigurationService, deps: [{ token: USE_CONFIGURATION_STORE }, { token: NgxPermissionsConfigurationStore }], target: i0.ɵɵFactoryTarget.Injectable });\nNgxPermissionsConfigurationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsConfigurationService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsConfigurationService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [USE_CONFIGURATION_STORE]\n                }] }, { type: NgxPermissionsConfigurationStore }]; } });\n\nclass NgxRolesStore {\n    constructor() {\n        this.rolesSource = new BehaviorSubject({});\n        this.roles$ = this.rolesSource.asObservable();\n    }\n}\n\nconst USE_ROLES_STORE = new InjectionToken('USE_ROLES_STORE');\nclass NgxRolesService {\n    constructor(isolate = false, rolesStore, permissionsService) {\n        this.isolate = isolate;\n        this.rolesStore = rolesStore;\n        this.permissionsService = permissionsService;\n        this.rolesSource = this.isolate ? new BehaviorSubject({}) : this.rolesStore.rolesSource;\n        this.roles$ = this.rolesSource.asObservable();\n    }\n    addRole(name, validationFunction) {\n        const roles = {\n            ...this.rolesSource.value,\n            [name]: { name, validationFunction }\n        };\n        this.rolesSource.next(roles);\n    }\n    addRoleWithPermissions(name, permissions) {\n        this.permissionsService.addPermission(permissions);\n        this.addRole(name, permissions);\n    }\n    addRoles(rolesObj) {\n        Object.keys(rolesObj).forEach((key, index) => {\n            this.addRole(key, rolesObj[key]);\n        });\n    }\n    addRolesWithPermissions(rolesObj) {\n        Object.keys(rolesObj).forEach((key, index) => {\n            this.addRoleWithPermissions(key, rolesObj[key]);\n        });\n    }\n    flushRoles() {\n        this.rolesSource.next({});\n    }\n    flushRolesAndPermissions() {\n        this.flushRoles();\n        this.permissionsService.flushPermissions();\n    }\n    removeRole(roleName) {\n        const roles = {\n            ...this.rolesSource.value\n        };\n        delete roles[roleName];\n        this.rolesSource.next(roles);\n    }\n    getRoles() {\n        return this.rolesSource.value;\n    }\n    getRole(name) {\n        return this.rolesSource.value[name];\n    }\n    hasOnlyRoles(names) {\n        const isNamesEmpty = !names || (Array.isArray(names) && names.length === 0);\n        if (isNamesEmpty) {\n            return Promise.resolve(true);\n        }\n        names = transformStringToArray(names);\n        return Promise.all([this.hasRoleKey(names), this.hasRolePermission(this.rolesSource.value, names)])\n            .then(([hasRoles, hasPermissions]) => {\n            return hasRoles || hasPermissions;\n        });\n    }\n    hasRoleKey(roleName) {\n        const promises = roleName.map((key) => {\n            const hasValidationFunction = !!this.rolesSource.value[key] &&\n                !!this.rolesSource.value[key].validationFunction &&\n                isFunction(this.rolesSource.value[key].validationFunction);\n            if (hasValidationFunction && !isPromise(this.rolesSource.value[key].validationFunction)) {\n                const validationFunction = this.rolesSource.value[key].validationFunction;\n                const immutableValue = { ...this.rolesSource.value };\n                return of(null).pipe(map(() => validationFunction(key, immutableValue)), switchMap((promise) => isBoolean(promise) ?\n                    of(promise) : promise), catchError(() => of(false)));\n            }\n            return of(false);\n        });\n        return from(promises).pipe(mergeAll(), first((data) => data !== false, false), map((data) => data !== false)).toPromise().then((data) => data);\n    }\n    hasRolePermission(roles, roleNames) {\n        return from(roleNames).pipe(mergeMap((key) => {\n            if (roles[key] && Array.isArray(roles[key].validationFunction)) {\n                return from(roles[key].validationFunction).pipe(mergeMap((permission) => this.permissionsService.hasPermission(permission)), every(hasPermission => hasPermission === true));\n            }\n            return of(false);\n        }), first(hasPermission => hasPermission === true, false)).toPromise();\n    }\n}\nNgxRolesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxRolesService, deps: [{ token: USE_ROLES_STORE }, { token: NgxRolesStore }, { token: NgxPermissionsService }], target: i0.ɵɵFactoryTarget.Injectable });\nNgxRolesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxRolesService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxRolesService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [USE_ROLES_STORE]\n                }] }, { type: NgxRolesStore }, { type: NgxPermissionsService }]; } });\n\nclass NgxPermissionsDirective {\n    constructor(permissionsService, configurationService, rolesService, viewContainer, changeDetector, templateRef) {\n        this.permissionsService = permissionsService;\n        this.configurationService = configurationService;\n        this.rolesService = rolesService;\n        this.viewContainer = viewContainer;\n        this.changeDetector = changeDetector;\n        this.templateRef = templateRef;\n        this.permissionsAuthorized = new EventEmitter();\n        this.permissionsUnauthorized = new EventEmitter();\n        // skip first run cause merge will fire twice\n        this.firstMergeUnusedRun = 1;\n    }\n    ngOnInit() {\n        this.viewContainer.clear();\n        this.initPermissionSubscription = this.validateExceptOnlyPermissions();\n    }\n    ngOnChanges(changes) {\n        const onlyChanges = changes['ngxPermissionsOnly'];\n        const exceptChanges = changes['ngxPermissionsExcept'];\n        if (onlyChanges || exceptChanges) {\n            // Due to bug when you pass empty array\n            if (onlyChanges && onlyChanges.firstChange) {\n                return;\n            }\n            if (exceptChanges && exceptChanges.firstChange) {\n                return;\n            }\n            merge(this.permissionsService.permissions$, this.rolesService.roles$)\n                .pipe(skip(this.firstMergeUnusedRun), take(1))\n                .subscribe(() => {\n                if (notEmptyValue(this.ngxPermissionsExcept)) {\n                    this.validateExceptAndOnlyPermissions();\n                    return;\n                }\n                if (notEmptyValue(this.ngxPermissionsOnly)) {\n                    this.validateOnlyPermissions();\n                    return;\n                }\n                this.handleAuthorisedPermission(this.getAuthorisedTemplates());\n            });\n        }\n    }\n    ngOnDestroy() {\n        if (this.initPermissionSubscription) {\n            this.initPermissionSubscription.unsubscribe();\n        }\n    }\n    validateExceptOnlyPermissions() {\n        return merge(this.permissionsService.permissions$, this.rolesService.roles$)\n            .pipe(skip(this.firstMergeUnusedRun))\n            .subscribe(() => {\n            if (notEmptyValue(this.ngxPermissionsExcept)) {\n                this.validateExceptAndOnlyPermissions();\n                return;\n            }\n            if (notEmptyValue(this.ngxPermissionsOnly)) {\n                this.validateOnlyPermissions();\n                return;\n            }\n            this.handleAuthorisedPermission(this.getAuthorisedTemplates());\n        });\n    }\n    validateExceptAndOnlyPermissions() {\n        Promise\n            .all([\n            this.permissionsService.hasPermission(this.ngxPermissionsExcept),\n            this.rolesService.hasOnlyRoles(this.ngxPermissionsExcept)\n        ])\n            .then(([hasPermission, hasRole]) => {\n            if (hasPermission || hasRole) {\n                this.handleUnauthorisedPermission(this.ngxPermissionsExceptElse || this.ngxPermissionsElse);\n                return;\n            }\n            if (!!this.ngxPermissionsOnly) {\n                throw false;\n            }\n            this.handleAuthorisedPermission(this.ngxPermissionsExceptThen || this.ngxPermissionsThen || this.templateRef);\n        })\n            .catch(() => {\n            if (!!this.ngxPermissionsOnly) {\n                this.validateOnlyPermissions();\n            }\n            else {\n                this.handleAuthorisedPermission(this.ngxPermissionsExceptThen || this.ngxPermissionsThen || this.templateRef);\n            }\n        });\n    }\n    validateOnlyPermissions() {\n        Promise\n            .all([this.permissionsService.hasPermission(this.ngxPermissionsOnly), this.rolesService.hasOnlyRoles(this.ngxPermissionsOnly)])\n            .then(([hasPermissions, hasRoles]) => {\n            if (hasPermissions || hasRoles) {\n                this.handleAuthorisedPermission(this.ngxPermissionsOnlyThen || this.ngxPermissionsThen || this.templateRef);\n            }\n            else {\n                this.handleUnauthorisedPermission(this.ngxPermissionsOnlyElse || this.ngxPermissionsElse);\n            }\n        })\n            .catch(() => {\n            this.handleUnauthorisedPermission(this.ngxPermissionsOnlyElse || this.ngxPermissionsElse);\n        });\n    }\n    handleUnauthorisedPermission(template) {\n        if (isBoolean(this.currentAuthorizedState) && !this.currentAuthorizedState) {\n            return;\n        }\n        this.currentAuthorizedState = false;\n        this.permissionsUnauthorized.emit();\n        if (this.getUnAuthorizedStrategyInput()) {\n            this.applyStrategyAccordingToStrategyType(this.getUnAuthorizedStrategyInput());\n            return;\n        }\n        if (this.configurationService.onUnAuthorisedDefaultStrategy && !this.elseBlockDefined()) {\n            this.applyStrategy(this.configurationService.onUnAuthorisedDefaultStrategy);\n        }\n        else {\n            this.showTemplateBlockInView(template);\n        }\n    }\n    handleAuthorisedPermission(template) {\n        if (isBoolean(this.currentAuthorizedState) && this.currentAuthorizedState) {\n            return;\n        }\n        this.currentAuthorizedState = true;\n        this.permissionsAuthorized.emit();\n        if (this.getAuthorizedStrategyInput()) {\n            this.applyStrategyAccordingToStrategyType(this.getAuthorizedStrategyInput());\n            return;\n        }\n        if (this.configurationService.onAuthorisedDefaultStrategy && !this.thenBlockDefined()) {\n            this.applyStrategy(this.configurationService.onAuthorisedDefaultStrategy);\n        }\n        else {\n            this.showTemplateBlockInView(template);\n        }\n    }\n    applyStrategyAccordingToStrategyType(strategy) {\n        if (isString(strategy)) {\n            this.applyStrategy(strategy);\n            return;\n        }\n        if (isFunction(strategy)) {\n            this.showTemplateBlockInView(this.templateRef);\n            strategy(this.templateRef);\n            return;\n        }\n    }\n    showTemplateBlockInView(template) {\n        this.viewContainer.clear();\n        if (!template) {\n            return;\n        }\n        this.viewContainer.createEmbeddedView(template);\n        this.changeDetector.markForCheck();\n    }\n    getAuthorisedTemplates() {\n        return this.ngxPermissionsOnlyThen\n            || this.ngxPermissionsExceptThen\n            || this.ngxPermissionsThen\n            || this.templateRef;\n    }\n    elseBlockDefined() {\n        return !!this.ngxPermissionsExceptElse || !!this.ngxPermissionsElse;\n    }\n    thenBlockDefined() {\n        return !!this.ngxPermissionsExceptThen || !!this.ngxPermissionsThen;\n    }\n    getAuthorizedStrategyInput() {\n        return this.ngxPermissionsOnlyAuthorisedStrategy ||\n            this.ngxPermissionsExceptAuthorisedStrategy ||\n            this.ngxPermissionsAuthorisedStrategy;\n    }\n    getUnAuthorizedStrategyInput() {\n        return this.ngxPermissionsOnlyUnauthorisedStrategy ||\n            this.ngxPermissionsExceptUnauthorisedStrategy ||\n            this.ngxPermissionsUnauthorisedStrategy;\n    }\n    applyStrategy(name) {\n        if (name === NgxPermissionsPredefinedStrategies.SHOW) {\n            this.showTemplateBlockInView(this.templateRef);\n            return;\n        }\n        if (name === NgxPermissionsPredefinedStrategies.REMOVE) {\n            this.viewContainer.clear();\n            return;\n        }\n        const strategy = this.configurationService.getStrategy(name);\n        this.showTemplateBlockInView(this.templateRef);\n        strategy(this.templateRef);\n    }\n}\nNgxPermissionsDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsDirective, deps: [{ token: NgxPermissionsService }, { token: NgxPermissionsConfigurationService }, { token: NgxRolesService }, { token: i0.ViewContainerRef }, { token: i0.ChangeDetectorRef }, { token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });\nNgxPermissionsDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.2\", type: NgxPermissionsDirective, selector: \"[ngxPermissionsOnly],[ngxPermissionsExcept]\", inputs: { ngxPermissionsOnly: \"ngxPermissionsOnly\", ngxPermissionsOnlyThen: \"ngxPermissionsOnlyThen\", ngxPermissionsOnlyElse: \"ngxPermissionsOnlyElse\", ngxPermissionsExcept: \"ngxPermissionsExcept\", ngxPermissionsExceptElse: \"ngxPermissionsExceptElse\", ngxPermissionsExceptThen: \"ngxPermissionsExceptThen\", ngxPermissionsThen: \"ngxPermissionsThen\", ngxPermissionsElse: \"ngxPermissionsElse\", ngxPermissionsOnlyAuthorisedStrategy: \"ngxPermissionsOnlyAuthorisedStrategy\", ngxPermissionsOnlyUnauthorisedStrategy: \"ngxPermissionsOnlyUnauthorisedStrategy\", ngxPermissionsExceptUnauthorisedStrategy: \"ngxPermissionsExceptUnauthorisedStrategy\", ngxPermissionsExceptAuthorisedStrategy: \"ngxPermissionsExceptAuthorisedStrategy\", ngxPermissionsUnauthorisedStrategy: \"ngxPermissionsUnauthorisedStrategy\", ngxPermissionsAuthorisedStrategy: \"ngxPermissionsAuthorisedStrategy\" }, outputs: { permissionsAuthorized: \"permissionsAuthorized\", permissionsUnauthorized: \"permissionsUnauthorized\" }, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngxPermissionsOnly],[ngxPermissionsExcept]'\n                }]\n        }], ctorParameters: function () { return [{ type: NgxPermissionsService }, { type: NgxPermissionsConfigurationService }, { type: NgxRolesService }, { type: i0.ViewContainerRef }, { type: i0.ChangeDetectorRef }, { type: i0.TemplateRef }]; }, propDecorators: { ngxPermissionsOnly: [{\n                type: Input\n            }], ngxPermissionsOnlyThen: [{\n                type: Input\n            }], ngxPermissionsOnlyElse: [{\n                type: Input\n            }], ngxPermissionsExcept: [{\n                type: Input\n            }], ngxPermissionsExceptElse: [{\n                type: Input\n            }], ngxPermissionsExceptThen: [{\n                type: Input\n            }], ngxPermissionsThen: [{\n                type: Input\n            }], ngxPermissionsElse: [{\n                type: Input\n            }], ngxPermissionsOnlyAuthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsOnlyUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsExceptUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsExceptAuthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsAuthorisedStrategy: [{\n                type: Input\n            }], permissionsAuthorized: [{\n                type: Output\n            }], permissionsUnauthorized: [{\n                type: Output\n            }] } });\n\nconst DEFAULT_REDIRECT_KEY = 'default';\n\nclass NgxPermissionsGuard {\n    constructor(permissionsService, rolesService, router) {\n        this.permissionsService = permissionsService;\n        this.rolesService = rolesService;\n        this.router = router;\n    }\n    canActivate(route, state) {\n        return this.hasPermissions(route, state);\n    }\n    canActivateChild(childRoute, state) {\n        return this.hasPermissions(childRoute, state);\n    }\n    canLoad(route) {\n        return this.hasPermissions(route);\n    }\n    canMatch(route) {\n        return this.hasPermissions(route);\n    }\n    hasPermissions(route, state) {\n        const routeDataPermissions = !!route && route.data ? route.data['permissions'] : {};\n        const permissions = this.transformPermission(routeDataPermissions, route, state);\n        if (this.isParameterAvailable(permissions.except)) {\n            return this.passingExceptPermissionsValidation(permissions, route, state);\n        }\n        if (this.isParameterAvailable(permissions.only)) {\n            return this.passingOnlyPermissionsValidation(permissions, route, state);\n        }\n        return true;\n    }\n    transformPermission(permissions, route, state) {\n        const only = isFunction(permissions.only)\n            ? permissions.only(route, state)\n            : transformStringToArray(permissions.only);\n        const except = isFunction(permissions.except)\n            ? permissions.except(route, state)\n            : transformStringToArray(permissions.except);\n        const redirectTo = permissions.redirectTo;\n        return {\n            only,\n            except,\n            redirectTo\n        };\n    }\n    isParameterAvailable(permission) {\n        return !!permission && permission.length > 0;\n    }\n    passingExceptPermissionsValidation(permissions, route, state) {\n        if (!!permissions.redirectTo\n            && ((isFunction(permissions.redirectTo))\n                || (isPlainObject(permissions.redirectTo) && !this.isRedirectionWithParameters(permissions.redirectTo)))) {\n            let failedPermission = '';\n            return from(permissions.except)\n                .pipe(mergeMap(permissionsExcept => {\n                return forkJoin([\n                    this.permissionsService.hasPermission(permissionsExcept),\n                    this.rolesService.hasOnlyRoles(permissionsExcept)\n                ]).pipe(tap(hasPermissions => {\n                    const dontHavePermissions = hasPermissions.every(hasPermission => hasPermission === false);\n                    if (!dontHavePermissions) {\n                        failedPermission = permissionsExcept;\n                    }\n                }));\n            }), first(hasPermissions => hasPermissions.some(hasPermission => hasPermission === true), false), mergeMap(isAllFalse => {\n                if (!!failedPermission) {\n                    this.handleRedirectOfFailedPermission(permissions, failedPermission, route, state);\n                    return of(false);\n                }\n                if (!isAllFalse && permissions.only) {\n                    return this.onlyRedirectCheck(permissions, route, state);\n                }\n                return of(!isAllFalse);\n            }))\n                .toPromise();\n        }\n        return Promise.all([\n            this.permissionsService.hasPermission(permissions.except),\n            this.rolesService.hasOnlyRoles(permissions.except)\n        ]).then(([hasPermission, hasRoles]) => {\n            if (hasPermission || hasRoles) {\n                if (permissions.redirectTo) {\n                    this.redirectToAnotherRoute(permissions.redirectTo, route, state);\n                }\n                return false;\n            }\n            if (permissions.only) {\n                return this.checkOnlyPermissions(permissions, route, state);\n            }\n            return true;\n        });\n    }\n    redirectToAnotherRoute(permissionRedirectTo, route, state, failedPermissionName) {\n        const redirectTo = isFunction(permissionRedirectTo)\n            ? permissionRedirectTo(failedPermissionName, route, state)\n            : permissionRedirectTo;\n        if (this.isRedirectionWithParameters(redirectTo)) {\n            redirectTo.navigationCommands = this.transformNavigationCommands(redirectTo.navigationCommands, route, state);\n            redirectTo.navigationExtras = this.transformNavigationExtras(redirectTo.navigationExtras, route, state);\n            this.router.navigate(redirectTo.navigationCommands, redirectTo.navigationExtras);\n            return;\n        }\n        if (Array.isArray(redirectTo)) {\n            this.router.navigate(redirectTo);\n        }\n        else {\n            this.router.navigate([redirectTo]);\n        }\n    }\n    isRedirectionWithParameters(object) {\n        return (isPlainObject(object) && (!!object.navigationCommands || !!object.navigationExtras));\n    }\n    transformNavigationCommands(navigationCommands, route, state) {\n        return isFunction(navigationCommands)\n            ? navigationCommands(route, state)\n            : navigationCommands;\n    }\n    transformNavigationExtras(navigationExtras, route, state) {\n        return isFunction(navigationExtras)\n            ? navigationExtras(route, state)\n            : navigationExtras;\n    }\n    onlyRedirectCheck(permissions, route, state) {\n        let failedPermission = '';\n        return from(permissions.only)\n            .pipe(mergeMap(permissionsOnly => {\n            return forkJoin([\n                this.permissionsService.hasPermission(permissionsOnly),\n                this.rolesService.hasOnlyRoles(permissionsOnly)\n            ]).pipe(tap(hasPermissions => {\n                const failed = hasPermissions.every(hasPermission => hasPermission === false);\n                if (failed) {\n                    failedPermission = permissionsOnly;\n                }\n            }));\n        }), first(hasPermissions => {\n            if (isFunction(permissions.redirectTo)) {\n                return hasPermissions.some(hasPermission => hasPermission === true);\n            }\n            return hasPermissions.every(hasPermission => hasPermission === false);\n        }, false), mergeMap((pass) => {\n            if (isFunction(permissions.redirectTo)) {\n                if (pass) {\n                    return of(true);\n                }\n                else {\n                    this.handleRedirectOfFailedPermission(permissions, failedPermission, route, state);\n                    return of(false);\n                }\n            }\n            else {\n                if (!!failedPermission) {\n                    this.handleRedirectOfFailedPermission(permissions, failedPermission, route, state);\n                }\n                return of(!pass);\n            }\n        }))\n            .toPromise();\n    }\n    handleRedirectOfFailedPermission(permissions, failedPermission, route, state) {\n        if (this.isFailedPermissionPropertyOfRedirectTo(permissions, failedPermission)) {\n            this.redirectToAnotherRoute(permissions.redirectTo[failedPermission], route, state, failedPermission);\n        }\n        else {\n            if (isFunction(permissions.redirectTo)) {\n                this.redirectToAnotherRoute(permissions.redirectTo, route, state, failedPermission);\n            }\n            else {\n                this.redirectToAnotherRoute(permissions.redirectTo[DEFAULT_REDIRECT_KEY], route, state, failedPermission);\n            }\n        }\n    }\n    isFailedPermissionPropertyOfRedirectTo(permissions, failedPermission) {\n        return (!!permissions.redirectTo && permissions.redirectTo[failedPermission]);\n    }\n    checkOnlyPermissions(purePermissions, route, state) {\n        const permissions = {\n            ...purePermissions\n        };\n        return Promise.all([\n            this.permissionsService.hasPermission(permissions.only),\n            this.rolesService.hasOnlyRoles(permissions.only)\n        ]).then(([hasPermission, hasRole]) => {\n            if (hasPermission || hasRole) {\n                return true;\n            }\n            if (permissions.redirectTo) {\n                this.redirectToAnotherRoute(permissions.redirectTo, route, state);\n            }\n            return false;\n        });\n    }\n    passingOnlyPermissionsValidation(permissions, route, state) {\n        if ((isFunction(permissions.redirectTo)\n            || isPlainObject(permissions.redirectTo) && !this.isRedirectionWithParameters(permissions.redirectTo))) {\n            return this.onlyRedirectCheck(permissions, route, state);\n        }\n        return this.checkOnlyPermissions(permissions, route, state);\n    }\n}\nNgxPermissionsGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsGuard, deps: [{ token: NgxPermissionsService }, { token: NgxRolesService }, { token: i3.Router }], target: i0.ɵɵFactoryTarget.Injectable });\nNgxPermissionsGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsGuard });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsGuard, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: NgxPermissionsService }, { type: NgxRolesService }, { type: i3.Router }]; } });\n\nclass NgxPermissionsAllowStubDirective {\n    constructor(viewContainer, templateRef) {\n        this.viewContainer = viewContainer;\n        this.templateRef = templateRef;\n        this.permissionsAuthorized = new EventEmitter();\n        this.permissionsUnauthorized = new EventEmitter();\n    }\n    ngOnInit() {\n        this.viewContainer.clear();\n        this.viewContainer.createEmbeddedView(this.getAuthorizedTemplate());\n        this.permissionsUnauthorized.emit();\n    }\n    getAuthorizedTemplate() {\n        return (this.ngxPermissionsOnlyThen ||\n            this.ngxPermissionsExceptThen ||\n            this.ngxPermissionsThen ||\n            this.templateRef);\n    }\n}\nNgxPermissionsAllowStubDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsAllowStubDirective, deps: [{ token: i0.ViewContainerRef }, { token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });\nNgxPermissionsAllowStubDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.2\", type: NgxPermissionsAllowStubDirective, isStandalone: true, selector: \"[ngxPermissionsOnly],[ngxPermissionsExcept]\", inputs: { ngxPermissionsOnly: \"ngxPermissionsOnly\", ngxPermissionsOnlyThen: \"ngxPermissionsOnlyThen\", ngxPermissionsOnlyElse: \"ngxPermissionsOnlyElse\", ngxPermissionsExcept: \"ngxPermissionsExcept\", ngxPermissionsExceptElse: \"ngxPermissionsExceptElse\", ngxPermissionsExceptThen: \"ngxPermissionsExceptThen\", ngxPermissionsThen: \"ngxPermissionsThen\", ngxPermissionsElse: \"ngxPermissionsElse\", ngxPermissionsOnlyAuthorisedStrategy: \"ngxPermissionsOnlyAuthorisedStrategy\", ngxPermissionsOnlyUnauthorisedStrategy: \"ngxPermissionsOnlyUnauthorisedStrategy\", ngxPermissionsExceptUnauthorisedStrategy: \"ngxPermissionsExceptUnauthorisedStrategy\", ngxPermissionsExceptAuthorisedStrategy: \"ngxPermissionsExceptAuthorisedStrategy\", ngxPermissionsUnauthorisedStrategy: \"ngxPermissionsUnauthorisedStrategy\", ngxPermissionsAuthorisedStrategy: \"ngxPermissionsAuthorisedStrategy\" }, outputs: { permissionsAuthorized: \"permissionsAuthorized\", permissionsUnauthorized: \"permissionsUnauthorized\" }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsAllowStubDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    standalone: true,\n                    selector: '[ngxPermissionsOnly],[ngxPermissionsExcept]',\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }, { type: i0.TemplateRef }]; }, propDecorators: { ngxPermissionsOnly: [{\n                type: Input\n            }], ngxPermissionsOnlyThen: [{\n                type: Input\n            }], ngxPermissionsOnlyElse: [{\n                type: Input\n            }], ngxPermissionsExcept: [{\n                type: Input\n            }], ngxPermissionsExceptElse: [{\n                type: Input\n            }], ngxPermissionsExceptThen: [{\n                type: Input\n            }], ngxPermissionsThen: [{\n                type: Input\n            }], ngxPermissionsElse: [{\n                type: Input\n            }], ngxPermissionsOnlyAuthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsOnlyUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsExceptUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsExceptAuthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsAuthorisedStrategy: [{\n                type: Input\n            }], permissionsAuthorized: [{\n                type: Output\n            }], permissionsUnauthorized: [{\n                type: Output\n            }] } });\n\nclass NgxPermissionsRestrictStubDirective {\n    constructor(viewContainer) {\n        this.viewContainer = viewContainer;\n        this.permissionsAuthorized = new EventEmitter();\n        this.permissionsUnauthorized = new EventEmitter();\n    }\n    ngOnInit() {\n        this.viewContainer.clear();\n        if (this.getUnAuthorizedTemplate()) {\n            this.viewContainer.createEmbeddedView(this.getUnAuthorizedTemplate());\n        }\n        this.permissionsUnauthorized.emit();\n    }\n    getUnAuthorizedTemplate() {\n        return (this.ngxPermissionsOnlyElse ||\n            this.ngxPermissionsExceptElse ||\n            this.ngxPermissionsElse);\n    }\n}\nNgxPermissionsRestrictStubDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsRestrictStubDirective, deps: [{ token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Directive });\nNgxPermissionsRestrictStubDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.2\", type: NgxPermissionsRestrictStubDirective, isStandalone: true, selector: \"[ngxPermissionsOnly],[ngxPermissionsExcept]\", inputs: { ngxPermissionsOnly: \"ngxPermissionsOnly\", ngxPermissionsOnlyThen: \"ngxPermissionsOnlyThen\", ngxPermissionsOnlyElse: \"ngxPermissionsOnlyElse\", ngxPermissionsExcept: \"ngxPermissionsExcept\", ngxPermissionsExceptElse: \"ngxPermissionsExceptElse\", ngxPermissionsExceptThen: \"ngxPermissionsExceptThen\", ngxPermissionsThen: \"ngxPermissionsThen\", ngxPermissionsElse: \"ngxPermissionsElse\", ngxPermissionsOnlyAuthorisedStrategy: \"ngxPermissionsOnlyAuthorisedStrategy\", ngxPermissionsOnlyUnauthorisedStrategy: \"ngxPermissionsOnlyUnauthorisedStrategy\", ngxPermissionsExceptUnauthorisedStrategy: \"ngxPermissionsExceptUnauthorisedStrategy\", ngxPermissionsExceptAuthorisedStrategy: \"ngxPermissionsExceptAuthorisedStrategy\", ngxPermissionsUnauthorisedStrategy: \"ngxPermissionsUnauthorisedStrategy\", ngxPermissionsAuthorisedStrategy: \"ngxPermissionsAuthorisedStrategy\" }, outputs: { permissionsAuthorized: \"permissionsAuthorized\", permissionsUnauthorized: \"permissionsUnauthorized\" }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsRestrictStubDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    standalone: true,\n                    selector: '[ngxPermissionsOnly],[ngxPermissionsExcept]',\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }]; }, propDecorators: { ngxPermissionsOnly: [{\n                type: Input\n            }], ngxPermissionsOnlyThen: [{\n                type: Input\n            }], ngxPermissionsOnlyElse: [{\n                type: Input\n            }], ngxPermissionsExcept: [{\n                type: Input\n            }], ngxPermissionsExceptElse: [{\n                type: Input\n            }], ngxPermissionsExceptThen: [{\n                type: Input\n            }], ngxPermissionsThen: [{\n                type: Input\n            }], ngxPermissionsElse: [{\n                type: Input\n            }], ngxPermissionsOnlyAuthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsOnlyUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsExceptUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsExceptAuthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsUnauthorisedStrategy: [{\n                type: Input\n            }], ngxPermissionsAuthorisedStrategy: [{\n                type: Input\n            }], permissionsAuthorized: [{\n                type: Output\n            }], permissionsUnauthorized: [{\n                type: Output\n            }] } });\n\nclass NgxPermissionsModule {\n    static forRoot(config = {}) {\n        return {\n            ngModule: NgxPermissionsModule,\n            providers: [\n                NgxPermissionsStore,\n                NgxRolesStore,\n                NgxPermissionsConfigurationStore,\n                NgxPermissionsService,\n                NgxPermissionsGuard,\n                NgxRolesService,\n                NgxPermissionsConfigurationService,\n                { provide: USE_PERMISSIONS_STORE, useValue: config.permissionsIsolate },\n                { provide: USE_ROLES_STORE, useValue: config.rolesIsolate },\n                { provide: USE_CONFIGURATION_STORE, useValue: config.configurationIsolate },\n            ]\n        };\n    }\n    static forChild(config = {}) {\n        return {\n            ngModule: NgxPermissionsModule,\n            providers: [\n                { provide: USE_PERMISSIONS_STORE, useValue: config.permissionsIsolate },\n                { provide: USE_ROLES_STORE, useValue: config.rolesIsolate },\n                { provide: USE_CONFIGURATION_STORE, useValue: config.configurationIsolate },\n                NgxPermissionsConfigurationService,\n                NgxPermissionsService,\n                NgxRolesService,\n                NgxPermissionsGuard\n            ]\n        };\n    }\n}\nNgxPermissionsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxPermissionsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsModule, declarations: [NgxPermissionsDirective], exports: [NgxPermissionsDirective] });\nNgxPermissionsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [],\n                    declarations: [\n                        NgxPermissionsDirective\n                    ],\n                    exports: [\n                        NgxPermissionsDirective\n                    ]\n                }]\n        }] });\nclass NgxPermissionsAllowStubModule {\n}\nNgxPermissionsAllowStubModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsAllowStubModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxPermissionsAllowStubModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsAllowStubModule, imports: [NgxPermissionsAllowStubDirective], exports: [NgxPermissionsAllowStubDirective] });\nNgxPermissionsAllowStubModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsAllowStubModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsAllowStubModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [NgxPermissionsAllowStubDirective],\n                    declarations: [],\n                    exports: [\n                        NgxPermissionsAllowStubDirective\n                    ]\n                }]\n        }] });\nclass NgxPermissionsRestrictStubModule {\n}\nNgxPermissionsRestrictStubModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsRestrictStubModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxPermissionsRestrictStubModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsRestrictStubModule, imports: [NgxPermissionsRestrictStubDirective], exports: [NgxPermissionsRestrictStubDirective] });\nNgxPermissionsRestrictStubModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsRestrictStubModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.2\", ngImport: i0, type: NgxPermissionsRestrictStubModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [NgxPermissionsRestrictStubDirective],\n                    declarations: [],\n                    exports: [\n                        NgxPermissionsRestrictStubDirective\n                    ]\n                }]\n        }] });\n\n/*\n * Public API Surface of ngx-permissions\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DEFAULT_REDIRECT_KEY, NgxPermissionsAllowStubDirective, NgxPermissionsAllowStubModule, NgxPermissionsConfigurationService, NgxPermissionsConfigurationStore, NgxPermissionsDirective, NgxPermissionsGuard, NgxPermissionsModule, NgxPermissionsPredefinedStrategies, NgxPermissionsRestrictStubDirective, NgxPermissionsRestrictStubModule, NgxPermissionsService, NgxPermissionsStore, NgxRolesService, NgxRolesStore, USE_CONFIGURATION_STORE, USE_PERMISSIONS_STORE, USE_ROLES_STORE };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}