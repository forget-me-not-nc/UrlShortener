{"ast":null,"code":"import { InjectionToken, NgModule } from '@angular/core';\n\n/**\n * An implementation of `StorageService` interface that uses an underlying (web) `Storage` object, such as `localStorage` and\n * `sessionStorage`, as backing data store. This class basically wraps the `Storage` object so it can be accessed through the\n * `StorageService` interface.\n */\nclass WebStorageService {\n  /**\n   * Creates a new `WebStorageService` instance that uses the specified (web) storage object as underlying backing storage.\n   *\n   * @param storage Storage object which is to be wrapped in a class that implements the `StorageService` interface.\n   */\n  constructor(storage) {\n    this.storage = storage;\n  }\n  /**\n   * Retrieves the value stored for the entry that is associated with the specified key. If no such entry exists or if the service for\n   * some reason is unable to fetch the value of the entry then `null` will be returned.\n   *\n   * @param   key Identifier of the entry whose value is to be retrieved.\n   * @returns     Value of the entry that is identified by the specified key or `null` if the entry does not exist or cannot be loaded.\n   */\n  get(key) {\n    try {\n      return JSON.parse(this.storage.getItem(key));\n    } catch (error) {\n      return null;\n    }\n  }\n  /**\n   * Creates or updates the entry identified by the specified key with the given value. Storing a value into the storage service will\n   * ensure that an equivalent of the value can be read back, i.e. the data and structure of the value will be the same. It, however, does\n   * not necessarily return the same value, i.e. the same reference.\n   *\n   * @param key   Identifier of the entry which is to be created or updated.\n   * @param value Value which is to be stored.\n   */\n  set(key, value) {\n    this.storage.setItem(key, JSON.stringify(value));\n  }\n  /**\n   * Removes the entry that is identified by the specified key. Attempting to remove an entry for an unknown key will have no effect.\n   * Attempting to retrieve an entry via the `get` method after it has been removed will result in `null`.\n   *\n   * @param key Identifier of the entry which is to be removed.\n   */\n  remove(key) {\n    this.storage.removeItem(key);\n  }\n}\n/**\n * Checks whether the specified (web) storage is available and functional. This might not be the case for older browsers. However even\n * certain browsers that do support the web storage API can, under some circumstances, have non functional storage objects. For example,\n * Safari is known to have `localStorage` and `sessionStorage` throw exceptions in private mode.\n *\n * @param storage Storage object which is to be tested for availability.\n */\nfunction isStorageAvailable(storage) {\n  // Check if storage is available.\n  if (!storage) {\n    return false;\n  }\n  // Check if the storage can actually be accessed.\n  try {\n    const now = Date.now();\n    const testItemKey = `storage-test-entry-${now}`;\n    const testItemValue = `storage-test-value-${now}`;\n    storage.setItem(testItemKey, testItemValue);\n    const retrievedItemValue = storage.getItem(testItemKey);\n    storage.removeItem(testItemKey);\n    return retrievedItemValue === testItemValue;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * A volatile `StorageService` implementation. This service guarantees that data stored will remain available as long as the application\n * instance is active. After the application is terminated all data will be lost.\n */\nclass InMemoryStorageService {\n  constructor() {\n    this.storage = new Map();\n  }\n  /**\n   * Retrieves the value stored for the entry that is associated with the specified key. If no such entry exists or if the service for\n   * some reason is unable to fetch the value of the entry then `null` will be returned.\n   *\n   * @param   key Identifier of the entry whose value is to be retrieved.\n   * @returns     Value of the entry that is identified by the specified key or `null` if the entry does not exist or cannot be loaded.\n   */\n  get(key) {\n    if (!this.storage.has(key)) {\n      return null;\n    }\n    return this.storage.get(key);\n  }\n  /**\n   * Creates or updates the entry identified by the specified key with the given value. Storing a value into the storage service will\n   * ensure that an equivalent of the value can be read back, i.e. the data and structure of the value will be the same. It, however, does\n   * not necessarily return the same value, i.e. the same reference.\n   *\n   * @param key   Identifier of the entry which is to be created or updated.\n   * @param value Value which is to be stored.\n   */\n  set(key, value) {\n    this.storage.set(key, value);\n  }\n  /**\n   * Removes the entry that is identified by the specified key. Attempting to remove an entry for an unknown key will have no effect.\n   * Attempting to retrieve an entry via the `get` method after it has been removed will result in `null`.\n   *\n   * @param key Identifier of the entry which is to be removed.\n   */\n  remove(key) {\n    this.storage.delete(key);\n  }\n}\n\n/** Injection token for the session storage service. */\nconst SESSION_STORAGE = new InjectionToken('SESSION_STORAGE');\n/** Injection token for the local storage service. */\nconst LOCAL_STORAGE = new InjectionToken('LOCAL_STORAGE');\nfunction sessionStorageFactory() {\n  if (!isStorageAvailable(sessionStorage)) {\n    return new InMemoryStorageService();\n  }\n  return new WebStorageService(sessionStorage);\n}\nfunction localStorageFactory() {\n  if (!isStorageAvailable(localStorage)) {\n    return new InMemoryStorageService();\n  }\n  return new WebStorageService(localStorage);\n}\nclass StorageServiceModule {}\nStorageServiceModule.decorators = [{\n  type: NgModule,\n  args: [{\n    providers: [{\n      provide: SESSION_STORAGE,\n      useFactory: sessionStorageFactory\n    }, {\n      provide: LOCAL_STORAGE,\n      useFactory: localStorageFactory\n    }]\n  }]\n}];\n/** @nocollapse */\nStorageServiceModule.ctorParameters = () => [];\nexport { WebStorageService, isStorageAvailable, InMemoryStorageService, SESSION_STORAGE, LOCAL_STORAGE, sessionStorageFactory, localStorageFactory, StorageServiceModule };","map":{"version":3,"names":["InjectionToken","NgModule","WebStorageService","constructor","storage","get","key","JSON","parse","getItem","error","set","value","setItem","stringify","remove","removeItem","isStorageAvailable","now","Date","testItemKey","testItemValue","retrievedItemValue","InMemoryStorageService","Map","has","delete","SESSION_STORAGE","LOCAL_STORAGE","sessionStorageFactory","sessionStorage","localStorageFactory","localStorage","StorageServiceModule","decorators","type","args","providers","provide","useFactory","ctorParameters"],"sources":["D:/Inforce/UrlShortener/UrlShortener/node_modules/angular-webstorage-service/bundles/angular-webstorage-service.js"],"sourcesContent":["import { InjectionToken, NgModule } from '@angular/core';\n\n/**\n * An implementation of `StorageService` interface that uses an underlying (web) `Storage` object, such as `localStorage` and\n * `sessionStorage`, as backing data store. This class basically wraps the `Storage` object so it can be accessed through the\n * `StorageService` interface.\n */\nclass WebStorageService {\n    /**\n     * Creates a new `WebStorageService` instance that uses the specified (web) storage object as underlying backing storage.\n     *\n     * @param storage Storage object which is to be wrapped in a class that implements the `StorageService` interface.\n     */\n    constructor(storage) {\n        this.storage = storage;\n    }\n    /**\n     * Retrieves the value stored for the entry that is associated with the specified key. If no such entry exists or if the service for\n     * some reason is unable to fetch the value of the entry then `null` will be returned.\n     *\n     * @param   key Identifier of the entry whose value is to be retrieved.\n     * @returns     Value of the entry that is identified by the specified key or `null` if the entry does not exist or cannot be loaded.\n     */\n    get(key) {\n        try {\n            return JSON.parse(this.storage.getItem(key));\n        }\n        catch (error) {\n            return null;\n        }\n    }\n    /**\n     * Creates or updates the entry identified by the specified key with the given value. Storing a value into the storage service will\n     * ensure that an equivalent of the value can be read back, i.e. the data and structure of the value will be the same. It, however, does\n     * not necessarily return the same value, i.e. the same reference.\n     *\n     * @param key   Identifier of the entry which is to be created or updated.\n     * @param value Value which is to be stored.\n     */\n    set(key, value) {\n        this.storage.setItem(key, JSON.stringify(value));\n    }\n    /**\n     * Removes the entry that is identified by the specified key. Attempting to remove an entry for an unknown key will have no effect.\n     * Attempting to retrieve an entry via the `get` method after it has been removed will result in `null`.\n     *\n     * @param key Identifier of the entry which is to be removed.\n     */\n    remove(key) {\n        this.storage.removeItem(key);\n    }\n}\n/**\n * Checks whether the specified (web) storage is available and functional. This might not be the case for older browsers. However even\n * certain browsers that do support the web storage API can, under some circumstances, have non functional storage objects. For example,\n * Safari is known to have `localStorage` and `sessionStorage` throw exceptions in private mode.\n *\n * @param storage Storage object which is to be tested for availability.\n */\nfunction isStorageAvailable(storage) {\n    // Check if storage is available.\n    if (!storage) {\n        return false;\n    }\n    // Check if the storage can actually be accessed.\n    try {\n        const now = Date.now();\n        const testItemKey = `storage-test-entry-${now}`;\n        const testItemValue = `storage-test-value-${now}`;\n        storage.setItem(testItemKey, testItemValue);\n        const retrievedItemValue = storage.getItem(testItemKey);\n        storage.removeItem(testItemKey);\n        return retrievedItemValue === testItemValue;\n    }\n    catch (error) {\n        return false;\n    }\n}\n\n/**\n * A volatile `StorageService` implementation. This service guarantees that data stored will remain available as long as the application\n * instance is active. After the application is terminated all data will be lost.\n */\nclass InMemoryStorageService {\n    constructor() {\n        this.storage = new Map();\n    }\n    /**\n     * Retrieves the value stored for the entry that is associated with the specified key. If no such entry exists or if the service for\n     * some reason is unable to fetch the value of the entry then `null` will be returned.\n     *\n     * @param   key Identifier of the entry whose value is to be retrieved.\n     * @returns     Value of the entry that is identified by the specified key or `null` if the entry does not exist or cannot be loaded.\n     */\n    get(key) {\n        if (!this.storage.has(key)) {\n            return null;\n        }\n        return this.storage.get(key);\n    }\n    /**\n     * Creates or updates the entry identified by the specified key with the given value. Storing a value into the storage service will\n     * ensure that an equivalent of the value can be read back, i.e. the data and structure of the value will be the same. It, however, does\n     * not necessarily return the same value, i.e. the same reference.\n     *\n     * @param key   Identifier of the entry which is to be created or updated.\n     * @param value Value which is to be stored.\n     */\n    set(key, value) {\n        this.storage.set(key, value);\n    }\n    /**\n     * Removes the entry that is identified by the specified key. Attempting to remove an entry for an unknown key will have no effect.\n     * Attempting to retrieve an entry via the `get` method after it has been removed will result in `null`.\n     *\n     * @param key Identifier of the entry which is to be removed.\n     */\n    remove(key) {\n        this.storage.delete(key);\n    }\n}\n\n/** Injection token for the session storage service. */\nconst SESSION_STORAGE = new InjectionToken('SESSION_STORAGE');\n/** Injection token for the local storage service. */\nconst LOCAL_STORAGE = new InjectionToken('LOCAL_STORAGE');\nfunction sessionStorageFactory() {\n    if (!isStorageAvailable(sessionStorage)) {\n        return new InMemoryStorageService();\n    }\n    return new WebStorageService(sessionStorage);\n}\nfunction localStorageFactory() {\n    if (!isStorageAvailable(localStorage)) {\n        return new InMemoryStorageService();\n    }\n    return new WebStorageService(localStorage);\n}\nclass StorageServiceModule {\n}\nStorageServiceModule.decorators = [\n    { type: NgModule, args: [{\n                providers: [\n                    { provide: SESSION_STORAGE, useFactory: sessionStorageFactory },\n                    { provide: LOCAL_STORAGE, useFactory: localStorageFactory }\n                ]\n            },] },\n];\n/** @nocollapse */\nStorageServiceModule.ctorParameters = () => [];\n\nexport { WebStorageService, isStorageAvailable, InMemoryStorageService, SESSION_STORAGE, LOCAL_STORAGE, sessionStorageFactory, localStorageFactory, StorageServiceModule };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}